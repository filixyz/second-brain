## 2.2.1 Overview of HTTP
The Hyper-Text Transfer protocol is the web’s application layer protocol. HTTP is implemented by two programs; a client (browser) and the server (web server), each operating on different end systems. They communicate with each other exchanging HTTP messages.

A web page is simply a document with multiple objects, an object is a file like video, jpeg or html text. most web pages consist of base html and numerous referenced objects. The referencing is done via URL.

A URL consists of two components: the host-name of the server that houses the object and its path-name.
```http
http://www.hostname.com/path/to/file.jpeg
```
HTTP define how web clients request web pages from web servers.

HTTP uses TCP as its underlying transport protocol. The HTTP client first initiates a TCP connection with the server. 
Then the client process uses its socket interface to relay requests to the server process and receives responses via that same socket, same analogy goes with the server process and it’s socket interface.

The HTTP web server and client browser relationship is a stateless one; meaning that HTTP connections typically do not store historical information pertaining to past messages exchanges between it’s servers and clients. It simply handles its current task, completes its and forgets about it within a connection and moves to the next task.

Hence its a **stateless protocol**.

## 2.2.2 Non Persistent and Persistent Connections
**Persistent TCP connections** are connections in which conversing end systems perform series of requests within the same TCP connection (multiple requests under one TCP connection).

**Non-Persistent TCP connections** are connections in which conversing end systems perform series request within each of their own TCP connection (one request for one TCP connection).

HTTP can be implemented to choose which over of the both.

**RTT**; Round Trip Time is the time elapsed from when a client makes a requests till when it actually receives the content it requested for from a server.
It can also be defined as the time taken for a small packet to travel from client to server and then back to the client.


## 2.2.3 HTTP Message Format
The HTTP specifications `[RFC 1945; RFC 7230; RFC 7540]` include the definitions of the HTTP message formats. There are two types of HTTP messages, request messages and responses messages.

### HTTP Request Message
This is a typical HTTP request message:
```http
GET /somedir/page.html HTTP/1.1
Host: www.someschool.edu
Connection: close
User-agent: Mozilla/5.0
Accept-language: fr
```
This is written in ordinary ASCII text and each line is followed by a carriage return and a line feed.

The first line is called the **request line** and subsequent lines are called **header lines**.
The request line has three fields:
1) the method field
2) the URL field and,
3) HTTP version field.
The method field can take several different values including `GET, POST, HEAD, PUT and DELETE`.

In the header lines we can see the `Host` field line that specified the host in which the GET request will be transmitted to. One might think that this header lines are unnecessary, due to the fact that for a client to be able to send messages it must had already established a TCP connection with the host address previously supplied.

But this information provided by header lines are required by web proxy caches. 

Here are some header lines and their meaning:
1)  `Connection: close` header line tells the server that we don’t want to bother with persistent connections; close connection after requested object has been sent
2) `User-agent: ` Specifies the user agent like Mozilla (typically the browser)
3) `Accept-Language:` The preferred language to receive a web object.
) 
![General HTTP request](imgs/General%20HTTP%20request.png)

different HTML commands:
1) `GET`: retrieves a web object
2) `POST`: retrieves a web object with some specified parameters (multiple)
3) `HEAD`: retrieves HTTP message without entity body (basically only the header lines); used for quantification (and possibly qualification) of a web object. Used in debugging.
4) `PUT`: uploads a web object
5) `DELETE`: deletes object on a web server.

### HTTP Response Message
Typical HTTP response message:
```http
HTTP/1.1 200 OK
Connection: close
Date: Tue, 18 Aug 2015 15:44:04 GMT
Server: Apache/2.2.3 (CentOs)
Last-Modified: Tue, 18 Aug 2015 15:11:03 GMT
Content-Length: 6821
Content-Type: text/html

(data data data data data ...)
```
The first line is the **status line**, the following six lines are  **header lines** and the last is the **entity body**.

The entity body is the meat of the message; the actual data we requested for.

The status line is composed of two fields: the protocol version, status code and corresponding status message. The rest are really self explanatory. The content length is in bytes.

Here are some common status codes with their associated phrases included:
1) `200 OK`: Request succeeded and information is returned in the response
2) `301 Moved Permanently`: Requested object has been permanently moved; new URL  attached to the `Location:` header of the response message. 
3) `400 Bad Request`: Request could not be understood
4) `404 Not Found`: Requested document does not exist on this server
5) `505 HTTP Version Not Supported:` Requested HTTP protocol version is not supported by the server.

## 2.2.4 User-Server Interaction: Cookies
Cookies enable HTTP connections (which are implicitly stateless) posses a state. This is useful for giving users identity in which historical data pertaining to that user identity can be retrieved from server when subsequent requests from that user are initiated.

cookies allow HTTP servers serve content as a function of the users identity.

Cookie technology posses four components:
1) A cookie header line in the HTTP response message
2) A cookie header line in the HTTP request message
3) A cookie file stored in the users end system, managed by its browser.
4) A back-end database at the web site that stores users data, with each user entry being accessible via the users cookie tag.

### A scenario explaining Cookies and how they preserve states
A user called Joseph uses his browser to browse the internet, now his browser has a database managed by his browsers that stores cookies entries, Now in the situation that Joseph makes a request, for the first time, to a website like amazon, in this case that browser initiates a connection to amazon server, Amazon notices that this is Joseph first interaction with it, so it creates a **state** (a historical backlog of data and interactions) by initializing a new cookie identifier for Joseph and stores Josephs interactions in its database with the newly created cookie identifier as an accessor to the data entry.

Now when amazon sends is response back to Josephs browser; it adds a `Set-cookie: 1234` response to its response header; upon receipt this prompts Joseph browser to store this new cookie entry into its database of accumulated cookies; `Cookie: 1234`

Now with any subsequent request to the amazon website; Josephs browser consults its cookie database, retrieves that cookie identifier for amazon and attaches it to it’s request message, now when amazon receives the request it notices the cookie header and makes sure its response is tailored to posses a state extrapolated from the data entries in its database Josephs cookie identifies with.

Cookies can be used to create a user session layer on top of stateless HTTP.

## 2.2.5 Web Caching
A web cache or a proxy server, is a network entity that satisfies request on behalf of the origin web server.

Once a browser is configures, each request is first sent to the web cache to be handle, if the web cache was unsuccessful in handling the request, it is then pushed to that actual origin server.

This is what happens; an overview:
1) First a browser; while trying to retrieve some object, opens a TCP connection to the web cache and sends an HTTP request.
2) The web cache upon receiving the request checks it’s database for a copy of the requested object. If found; it sends back an HTTP response to the browser with the object embedded.
3) if not found; the web cache then opens a TCP connection to the origin server and then send a HTTP requested object for the demanded object; upon the origin web server receiving the request, it responds with a HTTP response with the demanded object attached to the web cache.
4) The web cache then receives the object, stores a copy for later request handling, and sends a copy within an HTTP response message to the client over the existing TCP connection between it and the browser.

**Content Distribution Networks (CDN)** are web caches that play an important role in the internet.

### The Conditional GET
A problem can arise with web caches if browsers just blindly accept objects requested as long as the web cache happen to have it. This is because this can lead to browsers receiving **stale objects**, objects that have been updated in the origin web server but not at the cache (This is a scenario, they generally do update themselves from time to time).

Fortunately HTTP provides `conditional GET`s as a solution to this problem.

A HTTP request message is a conditional GET if the request contains a `GET` command and a `If-Modified-Since`: header line.

Web caches usually issue conditional `GET`s to origin web servers, if the object copy requested for by a client, have been in the web caches storage for quite a while.
## 2.2.6 HTTP/2
The goal of HTTP/2  are to reduce perceived latency by enable request response multiplexing over a single TCP connection, provide request prioritization and server push and provide efficient compression of HTTP header files.

## 2.3 Electronic Mail in the Internet
The electronic mail has been in around since the beginning of the Internet. The internet mail system posses three major components:
1) User agents
2) Mail servers
3) Simple Mail Transfer Protocol (SMTP)

User agents are apps like Gmail, when we compose emails they are sent to a mail server, where the message is placed in the mail server outgoing messages queue, when the recipient want to read the mail they check their mailbox in their mail server.

The mail server form the core email infrastructure, each recipient of a mail posses a mailbox in one of the mail servers.

is a mail server cannot deliver a mail places the mail in the messages queue and re-attempts to redeliver every 30 mins or so, until successful; if for some reason all reattempts fail, the server removes the message from the queue and notifies the sender.

SMTP is built upon the TCP protocol, it specifically relies on TCPs *reliable data transfer service*

SMTP posses two sides:
* The client side: which executes the senders mail server.
* The server side: which executes the recipients mail server.
Both sides run SMTP, the semantics of a generic client-server relationship is generally the opposite when it comes to SMTP; the sender is the client while the receiver is the server.

## 2.3.1 SMTP
SMTP is defined in RFC 5321. Due to how old mail technology is; SMTP generally till this day posses lots of archaic characteristics; For example it restricts body (not just headers) of all mail messages to simple 7-bit ASCII, which generally made sense in the early 1980s but now in our multimedia networked era it’s a bit of a pain; since to circumvent this restrictions it requires that binary data be encoded into ASCII by the sender and decoded to the required format by the receiver.

SMTP is a push protocol; it only sends, so to receive; the users user-agent can use HTTP or IMAP (Internet Mail Access Protocol) to receive messages from his own mail server.



