## Waiting with a time limit
All blocking calls discussed previously will block and suspend the invoking thread for an indefinite amount of time, in a lot of cases this is not ideal; we likely would prefer our blocking/waiting invocation to be subjected under some time limiting mechanism.

There are two sort of mechanism we can opt for:
1) **A duration based timeout**: subjecting the wait to limited time frame or,
2) **An absolute timeout**: where we wait until a specific point in time is present.

Most waiting functions in provide variants that handle both form of timeouts. The duration based timeout variants have a *`_for`* suffix, while the absolute timeout variants have an *`_until`* prefix.

for example `std::condition_variable` has two overloads of the `wait_for` member functions and two overloads of the `wait_until` member functions that corresponds to two of the overloads of `wait()` which are:
1) An overload that just waits until signaled, or a spurious wake-up occurs or if the timeout expires (in this case no predicate is supplied as an argument) and,
2) An overload that checks the supplied predicate when woken and will return only when the supplied predicate is true (and the the conditional variable signaled) or when the timeout expires.

### Clocks and the way c++ specifies time
A clock in c++ is a source of time information. Specifically a clock is a class that provides four distinct pieces of information:
* The time *now*
* The type of the value used to represent the times obtained from the clock
* The tick period of the clock
* Whether or not the clock ticks at uniform rate; therefore to be considered a *steady* clock.

The current time of a clock can be retrieved by invoking the `now()` static member function for a `clock` class, an example:
```c++
std::chrono::system_clock::now(); // returns currenttime of system clock
```
The type of time-points for a particular clock is specified by the `time_point` member `typedef`, so the return type of `some_clock::now()` is `some_clock::time_point`.

The tick period is specified as a fractional number in seconds: which is given by the `period` number `typedef` of the clock; a clock that ticks 25 times per second has a time a period of `std::ratio<1, 25>` ergo a clock that ticks every 2.5 second would have a period of `std::ratio<5, 2>`.

There is no guarantee that an observed tick period at program runtime will actually match the clocks actually defined tick period.

If a clock ticks at a uniform rate (whether or not that rate matches its period) and it’s value can’t be adjusted that clock is said to be a *a steady clock*. The `is_steady` static data member of a clock class returns `true` if said clock is steady.

`std::chrono::system_clock` is not steady; given it can be adjusted.

Steady clock are important for timeout calculations, as we’ll see shortly hence c++ provides:
1) `std::chrono::steady_clock`.

C++ also provides 2 other (mentioned) clocks, they are:
2) `std::chrono::system_clock`: This is the “real time” clock of the system, and
3) `std::chrono::high_resolution_clock`: This clock provides the smallest possible tick period (an thus is of the highest resolution of all library clocks)
These clocks are defined in the `<chrono>` library header.

### Durations
The Duration is the simplest part of time support in C++ they are handled via `std::chrono::duration<>` class template. All time related facilities in c++ are handled by the `<sdt::chrono>` namespace.

The first template parameter specifies the underlying numeric type in which the duration will be stored as (an `int`, `short` or whatnot) while the second parameter specifies the ratio a single unit of the duration evaluates to in seconds. An example:
```c++
// duration that counts in minutes
std::chrono::duration<short, std::ratio<60, 1>>; // 60 seconds == i unit
// duration that counts in milliseconds
std::chrono::duration<int, std::ratio<1, 1000>>; // i second == 1000 unit
```
The standard library contains predefined `typedef` in the `std::chrono` namespace for various popular durations: nano, micro, milliseconds, seconds, minutes, hours. There are also `typedefs` for a lot of SI ratios
```c++
// This is a typedef of a day duration
typedef std::chrono::duration<int, std::ratio<24*60*60, 1>> day;
```
For added convenience there are a number of predefined literal suffix operators for durations in the `std::chrono_literals` namespace; introduced with C++ 14:
```c++
using namespace std::chrono_literals;
auto one_day = 24h;
auto half_an_hour = 30min;
auto max_time_between_messages=30ms;
```
When this suffixes are used with integer literals they are equivalent to the default implementation of their associated predefined duration typedefs meaning:
```c++
std::chrono::nanoseconds(15) == 15ns
```
However with floating point literals this suffixes create a subtly scaled floating point representation of the duration resulting from the default implementations dependence on some unspecified floating point type.

So when concerned about the range of precision when dealing with floating point represented durations;  it’s best you rely on yourself and define one that suit your needs.

Conversions between durations of different counts are implicit when truncation is sure not to occur, this is the only case where conversion is implicit. If truncation will occur conversions must be explicitly declared via `std::chrono::duration_cast<>`:
```c++
std::chrono::milliseconds ms (54902);

// Belows conversion must be explicitly converted 
// since truncation is certain to occur
std::chrono::seconds s=
	std::chrono::duration_cast<std::chrono::seconds>(ms);

// Belows conversion is implicit since 
// it's certain truncation cannot occur.
std::chrono::milliseconds ms_2 = seconds;
```
Duration values are always truncated in events where normally one would expect them to be rounded. Durations also support arithmetic hence `5*chrono::seconds(1)` is equivalent to `chrono::seconds(5)` or `chrono::minutes(1) - chrono::seconds(55)`.

The count in the number of units in the duration can be obtained with the `count()` member function thus `chrono::seconds(1234).count()` will return 1234.

#### Duration Based Waits
Duration based waits are done with instance of `std::chrono::duration<>` for example:
```c++
std::future<int> f = std::async(some_task);
if(f.wait_for(std::chrono::milliseconds(35))==std::future_status::ready)
	do_something_with(f.get());
```
The `wait` functions return a status that represents the state of the future being waited upon:
1) `std::future_status::ready`, is the future has been prepared and is now *ready*
2) `std::future_status::deferred`, if the future task execution is deferred
3) `std::future_status::timeout`, if the timeout placed on the wait has expired.
The time for duration based waits are managed by c++ library internal steady clock.

### Time points
The time point of a clock is represented by an instance of the `std::chrono::time_point<>` class template. The first template parameter specifies the type of the clock and the second parameter represents the units of measurement (a specialization of `std::chrono::duration<>`)

A specific point in time is called the *epoch* of the clock. An epoch is a basic query but not one available to query or specified by the c++ standard. Typical epochs include `00:00` on January 1, 1970, and the instant when the computer running running the application booted up.

Although we can’t figure out when an epoch is, We can always get the time elapsed since an epoch via the `time_since_epoch()` member function for any given `time_point`; This returns a duration value that specifies such.

One can add and subtract durations from instances of `time_point`s to produce new `time_points`:
```c++
// This will return a time point
// with 500ns added to the time_point that reproesents now.
auto new_time_point = std::chrono::high_resolution_clock::now() +
	std::chrono::nanoseconds(500);
```
This is useful for calculating absolute timeouts when the maximum duration of a block of code is known beforehand.

Time_points that share the same clock can also be subtracted from each other. The result is durations specifying the chronological interval between those two time points, an example:
```c++
auto start = std::chrono::high_resolution_clock::now();
do_something();
auto stop  = std::chrono::high_resolution_clock::now();
std::cout << "do_something() took " << std::chrono::duration<double,
	std::ratio<1, 1>>(stop-start).count() << " seconds" << std::endl;
```
The clock template parameter argument in `time_point<>` does more than just specifying the epoch for time related computes; when time points are supplied into wait functions to manage an absolute timeout, time points use the clock supplied to them to measure the change in time.

This has important consequences if the clock is changed because wait functions track changes to manage absolute timeouts by NOT returning until the `time_point` clock’s `.now()` returns a time point later than the defined timeout.

`time_points` are used with the *`_until`* variants of the `wait` functions. Typical use case is a future offset of `some_clock::now()` at a fixed point in the program.

Time points can be associated with user clock by converting `time_t` to time points via `std::chrono::system_clock::to_time_point()` static member function; with this we can make time scheduling for events and other time related computes that are visible to users, since any time related event synchronization done was done relative to the users own visible time.

An example showing how to synchronize waits which the timeout is relative to the time point an event occurs:
```c++
Wiating For a conditon variable with a timepout.

#include <condition_variable>
#include <mutex>
#include <chrono>
std::condition_variable cv;
bool done;
std::mutex m;

bool wait_loop()
{
	auto const timeout = std::chrono::steady_clock::now() +
		std::chrono::milliseconds(500);
	std::unique_lock lk (m);
	while(!done)
	{
		if(cv.wait_unitl(lk, timeout)==std::cv_status::timeout)
			break;
	}
	return done;
}
```
This is the recommended way to wait for conditional variables with a time limit of a predicate is not being passed to wait. IN this way the overall length of the loop is bounded.

Using a `wait_for` makes the total wait time unbounded, since it would have to repeat for every loop.

It was discussed in section 4.1.1 that we need a loop when using conditional variables if a predicate was not passed in in order to handle spurious wake-ups; i do not remember that; re-read.

### Functions that accept timeouts
The simplest use for a timeout is limiting a threads’ total time in executing state by shutting it dormant when there’s nothing for the thread to do; forcing the thread not to occupy precious processing time that other threads could be utilizing, This can be achieved via thread delays.

There are two thread delay functions in c++; `std::this_thread::sleep_for()`(thread sleeps for a particular duration) and `std::this_thread::sleep_until()`(thread sleeps until a specified point in time), they operate just like alarm clocks.

`sleep_for()` makes sense for something that needs to be done (or checked) periodically, while can be used to schedule a thread to sleep and wake up at a certain point in time (like triggering backups at midnight).

Sleeping isn’t the only facility that timeouts are instrumental to; We are already aware they can be used in conditional variables and futures.

timeouts can also be used to acquire locks on mutex if the mutex supports it. Plain mutex and it’s recursive counterparts do not support the instrumentality of timeouts; hence c++ provides us with `std::timed_mutex` and `std::recursive_timed_mutex`. 

Both of this timed mutexes support `try_lock_for()` and `try_lock_until()`that try to obtain the lock until the specified timeout concludes.

The table 4.1 in the text illustrates c++ standard lib. that accept timeouts their parameters and their return values.
