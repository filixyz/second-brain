A feature in c++ std library is `std::thread::hardware_concurrency()`, This function returns the number of threads that can concurrently run for a given program execution. In multi-core systems its might be the number of cores in the system, if or returns 0 there, multi-threading is not possible. This function helps use design an estimation of the number of threads needed for a program. Here is an example that shows a way we can implement a concurrent version of `accumulate`.

The approach is to agree on the maximum workload a single thread is expected to run, and use the total size of “quantified operations” and estimate how many threads will be sufficient, while comparing the estimate to the number of threads can actually offer and distribute the load accordingly:
```c++
template <typename Iterator, typename T>
struct accumulate_block {
	void operator()(Iterator first, Iterator last, T& result) {
		result = std::accumulate(first, last, result);
	}
};

template <typename Iterator, typename T>
T parrallel_accumulate(Iterator first, Iterator last, T init){
	const unsigned long length = std::distance(first, last);
	if(!length) return init;
	
	const unsigned long min_per_thread = 25;
	const unsigned long max_threads = (length+min_per_thread-1)/
		min_per_thread;
	const unsigned long hardware_threads =
		std::thread::hardware_concurrency();
	const unsigned long threads_num =
		std::min(hardware_threads!=0?hardware_threads:2, max_threads);
	const unsigned long block_size = length/threads_num;

	vector<std::threads> v_threads(threads_num-1);
	vector<T> results (threads_num);
	Iterator block_start = first;
	for(unsigned long i = 0; i < (num_threads-1); ++i) {
		Iterator block_end = block_start;
		std::advance(block_end, block_size);
		x[i] = std::thread(accumulate_block, block_start, 
			block_end, std::ref(results[i]));
		block_start = block_end;
	}
	accumulate_block() (block_start, last, results[thread_num-1]);

	for(auto& entry : v_threads)
		entry.join();

	return std::accumulate(results.begin(), results.end(), init);
}
```
## 2.5 Identifying threads
Threads can be identified via `std::thread::id`, each threads has a unique value and threads that are the same posses the same `thread::id`. The `thread::id` objects comes supported with a plethora of operators like `<, ==`, so they can be compared, sorted and such. The current `std::thread::id` of an object can be retrieved via `.get_id()` instance member getter. Instance of `std::thread::id` are usually used to check if a thread required to perform some operation:
```c++
std::thread::id master_thread;
void some_core_part_of_algorithm()
{
	if(std::this_thread::get_id() == master_thread) {
		do_master_work();
	}
	do_common_work();
}
```
The `std::thread::id` of a running thread can be retrieved via the static function `std::this_thread::get_id()`, The `std::thread::id` can be printed via `cout` but its value likewise its output, is implementation dependent.